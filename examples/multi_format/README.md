# Multi-Format Response Example

Demonstrates Dream's elegant pattern for serving the same data in multiple formats (JSON, HTML, HTMX, CSV, streaming) with clean, maintainable code.

## Features Demonstrated

- **PathParam format detection** - `/products/1.json`, `/products/1.htmx`, `/products/1.csv`
- **Matcha templates** - Semantic HTML with Pico CSS (classless styling)
- **Flat controller pattern** - No nested cases, all named helper functions
- **Streaming responses** - CSV export as a stream of bytes
- **Type-safe SQL** - Squirrel-generated queries
- **Multiple formats per endpoint** - Same controller serves JSON, HTML, HTMX, CSV

## Running the Example

```bash
# Start database
make db-up

# Run migrations
make migrate

# Generate SQL code
make squirrel

# Compile Matcha templates
matcha

# Run the server
make run
```

Server will start on `http://localhost:3000`.

## Try It Out

```bash
# HTML - Full page with Pico CSS styling
curl http://localhost:3000/products/1

# JSON - API response
curl http://localhost:3000/products/1.json

# HTMX partial - Card component
curl http://localhost:3000/products/1.htmx

# CSV - Single row
curl http://localhost:3000/products/1.csv

# JSON list
curl http://localhost:3000/products.json

# Streaming CSV export
curl http://localhost:3000/products.csv
```

## Pattern Overview

### Model Layer (`models/product.gleam`)

Models provide `to_*` conversion functions:

- `to_json(product)` - Converts to JSON string
- `to_html(product)` - Calls Matcha template for full page
- `to_htmx(product)` - Calls Matcha template for partial
- `to_csv(product)` - Converts to CSV row
- `list_to_csv_stream(products)` - Streams CSV bytes

### View Layer (Matcha templates)

- `views/products/show.matcha` - Full HTML page with semantic markup
- `views/products/card.matcha` - HTMX partial (article component)
- `views/products/index.matcha` - Products list table

Templates use:
- Semantic HTML (no classes)
- Pico CSS for styling
- Lucide icons
- ARIA attributes for accessibility

### Controller Layer (`controllers/products_controller.gleam`)

Controllers use flat case pattern:

1. Extract PathParam
2. Check `param.as_int` for conversion
3. Query database
4. Match on `param.format` to choose converter
5. Return appropriate response

No nested cases, every function has a single responsibility.

## Code Structure

```
examples/multi_format/
├── gleam.toml                    # Project config
├── Makefile                      # Build commands
├── docker-compose.yml            # Database setup
├── src/
│   ├── main.gleam                # Entry point
│   ├── router.gleam              # Routes
│   ├── context.gleam             # App context
│   ├── services.gleam             # Database service
│   ├── database.gleam            # Database initialization
│   ├── sql.gleam                 # Generated by Squirrel
│   ├── models/
│   │   └── product.gleam        # Format converters (to_json, to_html, etc.)
│   ├── controllers/
│   │   └── products_controller.gleam # Multi-format controller
│   └── views/products/
│       ├── show.matcha           # Full page template
│       ├── card.matcha           # HTMX partial template
│       └── index.matcha          # List template
├── sql/
│   ├── get_product.sql          # SQL query definitions
│   └── list_products.sql
└── priv/migrations/              # Database migrations
```

## Key Takeaways

1. **Format is explicit** - Extension in URL (`/products/1.json`)
2. **Models own conversion** - All `to_*` functions in one place
3. **Templates are functions** - Matcha compiles to type-safe Gleam
4. **Flat, readable code** - No nesting, named helpers
5. **Separation of concerns** - Models convert, controllers route, templates render

See [Multi-Format Responses Tutorial](../../docs/tutorials/multi-format-responses.md) for complete documentation.

